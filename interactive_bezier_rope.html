
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Bézier Rope (Web) — Cubic Bézier + Spring Physics</title>
<style>
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:#0f1720;color:#dbeafe}
  .wrap{display:flex;gap:12px;height:100%;padding:12px;box-sizing:border-box}
  canvas{background:linear-gradient(180deg,#07102a,#07111f);border-radius:8px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  .left{flex:1;display:flex;align-items:center;justify-content:center}
  .panel{width:340px;display:flex;flex-direction:column;gap:10px}
  .card{background:rgba(255,255,255,0.03);padding:12px;border-radius:8px}
  label{font-size:13px;color:#9fb0d9}
  input[type=range]{width:100%}
  .hint{font-size:12px;color:#9fb0d9}
  .fps{font-weight:700;color:#9EE493}
  .footer{font-size:12px;color:#9fb0d9}
  .controls-row{display:flex;gap:8px;align-items:center}
  button{background:#0b1220;border:1px solid rgba(255,255,255,0.03);color:#dbeafe;padding:8px 10px;border-radius:6px;cursor:pointer}
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <canvas id="c" width="1000" height="640"></canvas>
  </div>
  <div class="panel">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div>
          <div style="font-weight:700;font-size:16px">Interactive Bézier Rope</div>
          <div class="hint">Cubic Bézier + spring-damper control points (P1,P2). Mouse / Drag to interact.</div>
        </div>
        <div class="fps" id="fps">-- FPS</div>
      </div>
      <div class="hint" style="margin-bottom:6px">Click & drag control points. Move mouse to influence P1/P2 targets.</div>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="reset">Reset</button>
        <button id="pinToggle">Pin Ends</button>
      </div>
    </div>

    <div class="card">
      <label>Spring stiffness (k): <span id="kVal">80</span></label>
      <input type="range" id="k" min="10" max="400" value="80">
      <label>Damping (c): <span id="dVal">12</span></label>
      <input type="range" id="d" min="0" max="80" value="12">
      <label>Sensitivity: <span id="sensVal">0.35</span></label>
      <input type="range" id="sens" min="0" max="1" step="0.01" value="0.35">
      <label>Tangent length: <span id="tLenVal">40</span> px</label>
      <input type="range" id="tLen" min="8" max="160" value="40">
    </div>

    <div class="card">
      <div style="font-weight:700;margin-bottom:6px">Notes</div>
      <div class="hint">This file implements the Bézier math, derivative, and spring physics from scratch. No external libraries used.</div>
      <div style="height:12px"></div>
      <div class="footer">Save this as .html → open in browser → record a short screen capture showing interactivity.</div>
    </div>
  </div>
</div>

<script>

class Vec2 {
  constructor(x=0,y=0){this.x=x;this.y=y}
  copy(){return new Vec2(this.x,this.y)}
  add(v){this.x+=v.x;this.y+=v.y;return this}
  sub(v){this.x-=v.x;this.y-=v.y;return this}
  mul(s){this.x*=s;this.y*=s;return this}
  len(){return Math.hypot(this.x,this.y)}
  norm(){const l=this.len()||1;this.x/=l;this.y/=l;return this}
  static add(a,b){return new Vec2(a.x+b.x,a.y+b.y)}
  static sub(a,b){return new Vec2(a.x-b.x,a.y-b.y)}
  static mul(a,s){return new Vec2(a.x*s,a.y*s)}
}


const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;


const kSlider = document.getElementById('k');
const dSlider = document.getElementById('d');
const sensSlider = document.getElementById('sens');
const tLenSlider = document.getElementById('tLen');
const fpsEl = document.getElementById('fps');
const kVal = document.getElementById('kVal');
const dVal = document.getElementById('dVal');
const sensVal = document.getElementById('sensVal');
const tLenVal = document.getElementById('tLenVal');

kSlider.oninput = ()=>kVal.textContent = kSlider.value;
dSlider.oninput = ()=>dVal.textContent = dSlider.value;
sensSlider.oninput = ()=>sensVal.textContent = sensSlider.value;
tLenSlider.oninput = ()=>tLenVal.textContent = tLenSlider.value;


const resetBtn = document.getElementById('reset');
const pinToggleBtn = document.getElementById('pinToggle');
let pinnedEnds = true;
pinToggleBtn.onclick = ()=>{pinnedEnds = !pinnedEnds; pinToggleBtn.textContent = pinnedEnds ? 'Pin Ends' : 'Unpin Ends';}
resetBtn.onclick = resetPositions;


const P0 = new Vec2(120, H-120); 
const P3 = new Vec2(W-120, 120); 

function ControlPoint(x,y){
  this.base = new Vec2(x,y); 
  this.pos = new Vec2(x,y);
  this.vel = new Vec2(0,0);
  this.target = new Vec2(x,y);
  this.radius = 8;
  this.dragging = false;
}

const cp1 = new ControlPoint(LERP(P0.x,P3.x,0.33), LERP(P0.y,P3.y,0.66));
const cp2 = new ControlPoint(LERP(P0.x,P3.x,0.66), LERP(P0.y,P3.y,0.33));

function LERP(a,b,t){return a+(b-a)*t}

let mouse = {x:W/2, y:H/2, down:false};
let lastTime = performance.now();
let fps = 0;


canvas.addEventListener('mousedown', (e)=>{
  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left, my = e.clientY - r.top;
  mouse.down = true;
  
  if(dist(mx,my,cp1.pos.x,cp1.pos.y) < 14){cp1.dragging = true}
  else if(dist(mx,my,cp2.pos.x,cp2.pos.y) < 14){cp2.dragging = true}
});
window.addEventListener('mouseup', ()=>{mouse.down = false; cp1.dragging=false; cp2.dragging=false});
canvas.addEventListener('mousemove', (e)=>{
  const r = canvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top;
  if(cp1.dragging){ cp1.pos.x = mouse.x; cp1.pos.y = mouse.y; cp1.vel.x = 0; cp1.vel.y = 0; cp1.base.x = cp1.pos.x; cp1.base.y = cp1.pos.y; }
  if(cp2.dragging){ cp2.pos.x = mouse.x; cp2.pos.y = mouse.y; cp2.vel.x = 0; cp2.vel.y = 0; cp2.base.x = cp2.pos.x; cp2.base.y = cp2.pos.y; }
});

function dist(x1,y1,x2,y2){return Math.hypot(x1-x2,y1-y2)}


function resetPositions(){
  cp1.base = new Vec2(LERP(P0.x,P3.x,0.33), LERP(P0.y,P3.y,0.66));
  cp1.pos = cp1.base.copy(); cp1.vel = new Vec2(0,0);
  cp2.base = new Vec2(LERP(P0.x,P3.x,0.66), LERP(P0.y,P3.y,0.33));
  cp2.pos = cp2.base.copy(); cp2.vel = new Vec2(0,0);
}


function bezierPoint(t, p0, p1, p2, p3){
  const u = 1 - t;
  const u3 = u*u*u;
  const u2t = 3 * u*u * t;
  const ut2 = 3 * u * t*t;
  const t3 = t*t*t;
  return new Vec2(
    u3 * p0.x + u2t * p1.x + ut2 * p2.x + t3 * p3.x,
    u3 * p0.y + u2t * p1.y + ut2 * p2.y + t3 * p3.y
  );
}

function bezierTangent(t, p0, p1, p2, p3){
  
  const u = 1 - t;
  const a = 3 * u * u; 
  const b = 6 * u * t; 
  const c = 3 * t * t; 
  return new Vec2(
    a*(p1.x - p0.x) + b*(p2.x - p1.x) + c*(p3.x - p2.x),
    a*(p1.y - p0.y) + b*(p2.y - p1.y) + c*(p3.y - p2.y)
  );
}


function updatePhysics(cp, dt){
  const k = parseFloat(kSlider.value);
  const damping = parseFloat(dSlider.value);
  if(!cp.dragging){
    const centerOffset = new Vec2(mouse.x - W/2, mouse.y - H/2);
    const sensitivity = parseFloat(sensSlider.value);
    cp.target.x = cp.base.x + centerOffset.x * sensitivity * 0.8; 
    cp.target.y = cp.base.y + centerOffset.y * sensitivity * 0.8;
  } else {
    cp.target.x = cp.pos.x; cp.target.y = cp.pos.y; 
  }
  const ax = -k * (cp.pos.x - cp.target.x) - damping * cp.vel.x;
  const ay = -k * (cp.pos.y - cp.target.y) - damping * cp.vel.y;
  cp.vel.x += ax * dt; cp.vel.y += ay * dt;
  cp.pos.x += cp.vel.x * dt; cp.pos.y += cp.vel.y * dt;
}


function drawCurve(p0,p1,p2,p3){
  ctx.lineWidth = 3;
  ctx.beginPath();
  const step = 0.01;
  let prev = bezierPoint(0,p0,p1,p2,p3);
  ctx.moveTo(prev.x, prev.y);
  for(let t=step; t<=1+1e-9; t+=step){
    const pt = bezierPoint(t,p0,p1,p2,p3);
    ctx.lineTo(pt.x, pt.y);
    prev = pt;
  }
  ctx.strokeStyle = 'rgba(174,214,255,0.95)';
  ctx.stroke();
}

function drawTangents(p0,p1,p2,p3){
  const tLen = parseFloat(tLenSlider.value);
  ctx.lineWidth = 1.5;
  for(let t=0; t<=1; t+=0.08){
    const pt = bezierPoint(t,p0,p1,p2,p3);
    const tan = bezierTangent(t,p0,p1,p2,p3);
    const nx = tan.x, ny = tan.y; 
    const L = Math.hypot(nx,ny)||1;
    const ux = nx / L, uy = ny / L;
    ctx.beginPath();
    ctx.moveTo(pt.x - ux * tLen * 0.4, pt.y - uy * tLen * 0.4);
    ctx.lineTo(pt.x + ux * tLen, pt.y + uy * tLen);
    ctx.strokeStyle = 'rgba(135,206,250,0.7)';
    ctx.stroke();
  }
}

function drawControlPoints(){
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.beginPath(); ctx.arc(P0.x,P0.y,6,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(P3.x,P3.y,6,0,Math.PI*2); ctx.fill();

  function drawCP(cp, fill){
    ctx.beginPath(); ctx.arc(cp.pos.x, cp.pos.y, cp.radius+2, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.03)'; ctx.fill();
    ctx.beginPath(); ctx.arc(cp.pos.x, cp.pos.y, cp.radius, 0, Math.PI*2);
    ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth=1; ctx.stroke();
  }
  drawCP(cp1, cp1.dragging? 'rgb(255,180,120)' : 'rgb(255,120,130)');
  drawCP(cp2, cp2.dragging? 'rgb(120,255,180)' : 'rgb(120,180,255)');
}

function drawGuide(){
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(P0.x,P0.y); ctx.lineTo(cp1.pos.x,cp1.pos.y); ctx.lineTo(cp2.pos.x,cp2.pos.y); ctx.lineTo(P3.x,P3.y);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.stroke();
}


function loop(ts){
  const dtRaw = Math.min((ts - lastTime)/1000, 0.033); 
  lastTime = ts;

  fps = 0.9*fps + 0.1*(1/dtRaw || 60);
  fpsEl.textContent = Math.round(fps) + ' FPS';

  updatePhysics(cp1, dtRaw);
  updatePhysics(cp2, dtRaw);

  if(!pinnedEnds){
    const mx = mouse.x, my = mouse.y;
    P0.x += (mx*0.02 - P0.x) * dtRaw * 1.2;
    P0.y += (my*0.02 - P0.y) * dtRaw * 1.2;
    P3.x += ((W - mx)*0.02 - (W-P3.x)) * dtRaw * 1.2;
    P3.y += ((H - my)*0.02 - (H-P3.y)) * dtRaw * 1.2;
  }

  ctx.clearRect(0,0,W,H);

  ctx.save();
  ctx.shadowColor = 'rgba(40,140,255,0.08)'; ctx.shadowBlur = 18;
  drawCurve(P0, cp1.pos, cp2.pos, P3);
  ctx.restore();

  drawTangents(P0, cp1.pos, cp2.pos, P3);
  drawCurve(P0, cp1.pos, cp2.pos, P3);
  drawGuide();
  drawControlPoints();

  requestAnimationFrame(loop);
}

resetPositions();
requestAnimationFrame(loop);

</script>
</body>
</html>
